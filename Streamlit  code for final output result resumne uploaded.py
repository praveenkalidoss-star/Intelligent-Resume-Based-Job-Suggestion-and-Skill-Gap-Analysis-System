# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i6H1zt446WnEXMFtsvHQOl-JyeaRR4bT
"""

import streamlit as st
from pymongo import MongoClient
import pandas as pd
import matplotlib.pyplot as plt
import requests
import os
from datetime import datetime

# =====================================================
# CONFIG
# =====================================================
st.set_page_config(
    page_title="AI Resume-Based Job Recommendation System",
    layout="wide"
)

# MongoDB
MONGO_URI = os.getenv(
    "MONGO_URI",
    "MONGO_URI"  # Need to enter the mongo db URI in this line
)

# API Gateway
JOB_REFRESH_API = " API key " # In this line need to enter a Job refresh API which is created using AWS API Gateway

skills_of_interest = ["python", "sql", "aws", "docker", "spark", "mlops"]

# =====================================================
# DB CONNECTION
# =====================================================
client = MongoClient(MONGO_URI)
db = client["resume_ai"]

resume = db["resumes"].find_one(sort=[("created_at", -1)])

# =====================================================
# JOB FETCH LOGIC (FIXED)
# =====================================================

# 1Ô∏è‚É£ Get jobs WITH final_score
ranked_jobs = list(
    db["jobs"]
    .find({"final_score": {"$exists": True}})
    .sort("final_score", -1)
)

# 2Ô∏è‚É£ If less than 20, fill remaining from unranked jobs
if len(ranked_jobs) < 20:
    remaining = 20 - len(ranked_jobs)

    unranked_jobs = list(
        db["jobs"]
        .find({"final_score": {"$exists": False}})
        .limit(remaining)
    )

    jobs = ranked_jobs + unranked_jobs
else:
    jobs = ranked_jobs[:20]

# =====================================================
# HEADER
# =====================================================
st.title("üéØ AI Resume-Based Job Recommendation System")

# =====================================================
# RESUME SUMMARY
# =====================================================
st.subheader("üìÑ Resume Summary")

if resume:
    st.write("**Email:**", resume.get("email", "Not detected"))
    st.write("**Skills:**", ", ".join(resume.get("skills", [])) or "Not detected")
    st.write("**Education:**", ", ".join(resume.get("education", [])) or "Not detected")
else:
    st.warning("No resume uploaded yet")

# =====================================================
# JOB RECOMMENDATIONS
# =====================================================
st.subheader("üèÜ Top Job Recommendations")

if not jobs:
    st.warning("No job recommendations available yet")
else:
    if len(jobs) < 20:
        st.info(f"Only {len(jobs)} jobs are currently available")

    for i, job in enumerate(jobs, start=1):
        st.markdown(f"### {i}. {job.get('title', 'Unknown Role')} ‚Äî {job.get('company', 'Unknown Company')}")

        score = job.get("final_score", 0.0)
        st.write(f"**Final Score:** {round(score, 3)}")

        st.markdown("**Why this job is recommended:**")
        st.markdown("""
        - Resume similarity analysis
        - Skill relevance
        - Job recency
        - Market demand
        """)

        col1, col2 = st.columns(2)

        with col1:
            if st.button(f"üëç Like {i}", key=f"like_{i}"):
                db["feedback"].insert_one({
                    "job_id": job["_id"],
                    "feedback": "like",
                    "timestamp": datetime.utcnow()
                })
                st.success("Feedback saved")

        with col2:
            if st.button(f"üëé Dislike {i}", key=f"dislike_{i}"):
                db["feedback"].insert_one({
                    "job_id": job["_id"],
                    "feedback": "dislike",
                    "timestamp": datetime.utcnow()
                })
                st.info("Feedback saved")

        st.divider()

# =====================================================
# SKILL GAP ANALYSIS
# =====================================================
st.subheader("üìä Skill Gap Analysis")

if resume and jobs:
    resume_skills = set(s.lower() for s in resume.get("skills", []))
    job_text = " ".join(j.get("description", "") for j in jobs).lower()

    resume_vector = [1 if s in resume_skills else 0 for s in skills_of_interest]
    job_vector = [1 if s in job_text else 0 for s in skills_of_interest]

    df = pd.DataFrame(
        [resume_vector, job_vector],
        columns=skills_of_interest,
        index=["Resume", "Job Market"]
    )

    fig, ax = plt.subplots(figsize=(7, 2))
    ax.imshow(df.values, aspect="auto")
    ax.set_xticks(range(len(df.columns)))
    ax.set_xticklabels(df.columns, rotation=45)
    ax.set_yticks(range(2))
    ax.set_yticklabels(df.index)
    ax.set_title("Skill Gap Heatmap")

    st.pyplot(fig)
else:
    st.warning("Upload resume to view skill gap")

# =====================================================
# RECOMMENDED COURSES
# =====================================================
st.subheader("üìö Recommended Courses")

if resume:
    missing_skills = [s for s in skills_of_interest if s not in resume.get("skills", [])]
    if missing_skills:
        for skill in missing_skills:
            st.markdown(f"- **{skill.upper()}** ‚Üí Coursera / Udemy")
    else:
        st.success("You already meet all key skills üéâ")

# =====================================================
# DAILY JOB REFRESH
# =====================================================
st.subheader("üîÑ Daily Job Refresh")

if st.button("Refresh Live Jobs"):
    try:
        with st.spinner("Refreshing live jobs..."):
            r = requests.post(JOB_REFRESH_API, timeout=15)

        if r.status_code == 200:
            st.success("‚úÖ Live jobs refreshed successfully")
        else:
            st.error(f"‚ùå Refresh failed ({r.status_code})")

    except Exception as e:
        st.error(f"‚ùå API error: {e}")

# =====================================================
# FOOTER
# =====================================================
st.caption(
    "Feedback is stored and used to adjust ranking weights in future recommendation cycles."
)